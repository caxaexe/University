# Лабораторная работа №6. Взаимодействие контейнеров

## Цель работы
Цель данной лабораторной работы является изучение управления взаимодействием нескольких контейнеров.  

## Задание
Создать php приложение на базе двух контейнеров: nginx, php-fpm.  

## Ход работы
Для начала выполнения данной лабораторной работы я создаю репозиторий `containers06`, внутри которого я также создаю папки `mounts/site`, куда добавляю свой самый лучший идеальный сайт про начос на php. Далее создаю файл `.gitignore` в корне папки со следующим содержимым:
```
# Ignore files and directories
mounts/site/*
```
![image](https://github.com/user-attachments/assets/8277d570-e7c1-4aeb-a257-1d446f41d929)  

Затем создаю папку `nginx` с файлом `default.conf`, внутри которого находится:
```
server {
    listen 80;
    server_name _;
    root /var/www/html;
    index index.php;
    location / {
        try_files $uri $uri/ /index.php?$args;
    }
    location ~ \.php$ {
        fastcgi_pass backend:9000;
        fastcgi_index index.php;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        include fastcgi_params;
    }
}
```
![image](https://github.com/user-attachments/assets/02c7a677-8d11-4c82-af73-36dc59da7e1c)  

---

Создаю сеть `internal` для контейнеров:
![Снимок экрана 2025-04-04 134101](https://github.com/user-attachments/assets/492b69c5-cd38-4320-8e9e-25c1a986c122)  

Далее создаю контейнер `backend` со свойствами: на базе образа php:7.4-fpm; к контейнеру примонтирована директория mounts/site в /var/www/html; работает в сети internal:
```
docker run -d `
    --name frontend `
    --network internal `
    -v ${PWD}\mounts\site:/var/www/html `
    -v ${PWD}\nginx\default.conf:/etc/nginx/conf.d/default.conf `
    -p 80:80 `
    nginx:1.23-alpine
```
![Снимок экрана 2025-04-04 134317](https://github.com/user-attachments/assets/0fc20e48-8a5e-4926-b62d-a62cba9a8240)  

Создаю контейнер frontend со свойствами: на базе образа nginx:1.23-alpine; с примонтированной директорией mounts/site в /var/www/html; с примонтированным файлом nginx/default.conf в /etc/nginx/conf.d/default.conf; порт 80 контейнера проброшен на порт 80 хоста; работает в сети internal:
```
docker run -d `
    --name frontend `
    --network internal `
    -v ${PWD}\mounts\site:/var/www/html `
    -v ${PWD}\nginx\default.conf:/etc/nginx/conf.d/default.conf `
    -p 80:80 `
    nginx:1.23-alpine
```  
![Снимок экрана 2025-04-04 134348](https://github.com/user-attachments/assets/be9318bc-3485-4a7c-a8c9-84c146ef5e7d)  

И на итоговом этапе я тестирую работоспособность своего самого лучшего идеального сайта про начос. Перехожу по адресной строке `http://localhost` и получаю следующий результат: ヽ(°〇°)ﾉ 
![Снимок экрана 2025-04-04 134602](https://github.com/user-attachments/assets/bbf7a082-67a4-434c-ad89-889e1c223c41)

## Вывод
В ходе выполнения практического задания была развернута простая веб-инфраструктура на основе Docker-контейнеров, включающая веб-сервер (Nginx) и интерпретатор PHP (PHP-FPM). 

## Контрольные вопросы
**1. Каким образом в данном примере контейнеры могут взаимодействовать друг с другом?**  
Контейнеры могут взаимодействовать друг с другом с помощью Docker сети. В данном примере, если контейнеры находятся в одной bridge-сети (например, `internal`), они могут обращаться друг к другу по именам контейнеров (hostname) вместо IP-адресов. Это возможно благодаря встроенному DNS-серверу Docker. Например, если один контейнер запущен с именем `app`, а другой с именем `db`, то контейнер `app` может обратиться к базе данных по адресу `db:порт`.  

**2. Как видят контейнеры друг друга в рамках сети internal?**  
В рамках сети `internal` контейнеры видят друг друга только внутри этой сети. Они не доступны извне, так как `internal` — это изолированная сеть без внешнего выхода. Контейнеры могут взаимодействовать по внутренним именам хостов, но не по внешним IP или стандартным localhost-адресам.

**3. Почему необходимо было переопределять конфигурацию nginx?**  
Конфигурация Nginx была переопределена, скорее всего, для:
- Настройки проксирования запросов к другим контейнерам (например, перенаправление `/api` на backend).
- Использования имен контейнеров вместо IP-адресов, чтобы Nginx мог обращаться к сервисам внутри Docker-сети.
- Изменения портов или добавления HTTPS (если стандартная конфигурация не подходит).
- Оптимизации кэша, Gzip-сжатия и других параметров для ускорения работы сервера.
